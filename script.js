// script.js

function runCheck() {
  const modeA = document.getElementById("modeA").checked;
  const modeB = document.getElementById("modeB").checked;
  const sourceText = document.getElementById("sourceText").value;
  const designText = document.getElementById("designText").value;
  const resultDiv = document.getElementById("result");
  let result = "";

  // A„É¢„Éº„ÉâÔºö‰æ°Ê†º„ÉÅ„Çß„ÉÉ„ÇØ & Ë°®Ë®ò„ÇÜ„Çå
  if (modeA) {
    result += "üßæ„Äê‰æ°Ê†º„ÉÅ„Çß„ÉÉ„ÇØ„Äë\n";

    const lines = designText.split(/\r?\n/);
    let matchCount = 0;

    for (const line of lines) {
      // ÂêÑÁ®Æ„Éë„Çø„Éº„É≥ÂØæÂøúÔºàÊüîËªü„Å´Ôºâ
      const pattern = /([\d,]{2,5})ÂÜÜ\s*[Ôºà(]?(Á®éËæº‰æ°Ê†º|Á®éÊäú‰æ°Ê†º|Êú¨‰Ωì‰æ°Ê†º)?[Ôºö:\s]?([\d,]{2,5})ÂÜÜ[Ôºâ)]?/g;
      const matches = [...line.matchAll(pattern)];

      for (const match of matches) {
        const val1 = parseInt(match[1].replace(/,/g, ""));
        const label = match[2];
        const val2 = parseInt(match[3].replace(/,/g, ""));
        matchCount++;

        if (!label) {
          const big = Math.max(val1, val2);
          const small = Math.min(val1, val2);
          const expected = Math.round(small * 1.1);
          const rel = Math.abs(big - expected) <= 1 ? "OK" : `‚ùå Ë™§Â∑Æ„ÅÇ„ÇäÔºö${big}ÂÜÜ ‚â† ${expected}ÂÜÜ`;
          result += `‚ö† „É©„Éô„É´„Å™„ÅóÔºö${val1}ÂÜÜ ‚áÑ ${val2}ÂÜÜ ‚Üí ${rel}\n`;
        } else if (label.includes("Á®éÊäú")) {
          const expected = Math.round(val2 * 1.1);
          if (Math.abs(val1 - expected) > 1) {
            result += `‚ùå Á®éÊäú${val2}ÂÜÜ ‚Üí Á®éËæº„ÅØ ${expected}ÂÜÜ„ÅÆ„ÅØ„Åö ‚Üí ÂÆüÈöõ: ${val1}ÂÜÜ\n`;
          } else {
            result += `‚úÖ Á®éÊäú${val2}ÂÜÜ ‚Üí Á®éËæº${val1}ÂÜÜÔºàOKÔºâ\n`;
          }
        } else if (label.includes("Á®éËæº")) {
          const expected = Math.round(val1 * 1.1);
          if (Math.abs(val2 - expected) > 1) {
            result += `‚ùå Á®éÊäú${val1}ÂÜÜ ‚Üí Á®éËæº„ÅØ ${expected}ÂÜÜ„ÅÆ„ÅØ„Åö ‚Üí ÂÆüÈöõ: ${val2}ÂÜÜ\n`;
          } else {
            result += `‚úÖ Á®éÊäú${val1}ÂÜÜ ‚Üí Á®éËæº${val2}ÂÜÜÔºàOKÔºâ\n`;
          }
        } else {
          result += `‚ö† ${label}Ôºö${val1}ÂÜÜ ‚áÑ ${val2}ÂÜÜ ‚Üí „É©„Éô„É´Âà§ÂÆö„Åß„Åç„Åö\n`;
        }
      }
    }

    if (matchCount === 0) {
      result += "‚ö† ‰æ°Ê†ºÂΩ¢Âºè„ÅåË¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì\n";
    }

    // Âçò‰ΩçË°®Ë®ò„ÉÅ„Çß„ÉÉ„ÇØ
    result += "\nüì¶„ÄêÊï∞Èáè„ÉªÂçò‰Ωç„ÉÅ„Çß„ÉÉ„ÇØ„Äë\n";
    const unitRegex = /\d+(ÂÄã|„Ç≥|„É∂|„Ç±|ÂÄãÂÖ•|Êûö|Êú¨|Êú¨ÂÖ•)/g;
    const unitMatches = [...designText.matchAll(unitRegex)].map(m => m[1]);
    const uniqueUnits = [...new Set(unitMatches)];
    if (uniqueUnits.length <= 1) {
      result += `‚úÖ Ë°®Ë®ò„ÇÜ„Çå„Å™„ÅóÔºà${uniqueUnits[0] || "Âçò‰ΩçÊú™Ê§úÂá∫"}Ôºâ\n`;
    } else {
      result += `‚ö† Ë°®Ë®ò„ÇÜ„Çå„ÅÇ„ÇäÔºö„Äå${uniqueUnits.join("„Äç„Äå")}„Äç„ÅåÊ∑∑Âú®„Åó„Å¶„ÅÑ„Åæ„Åô\n`;
    }
    result += "\n";
  }

  // B„É¢„Éº„ÉâÔºö„ÉÜ„Ç≠„Çπ„ÉàÂ∑ÆÂàÜÔºàÂçòË™û/ÊñáÂçò‰Ωç„ÅßÂê´„Åæ„Çå„Å¶„ÅÑ„Çã„ÅãÔºâ
  if (modeB) {
    const srcLines = sourceText.split(/\r?\n/).map(line => line.trim()).filter(line => line);
    const desText = designText.replace(/\s+/g, " ");
    result += "üìÑ„ÄêÂ∑ÆÂàÜ„ÉÅ„Çß„ÉÉ„ÇØ„Äë\n";
    srcLines.forEach((line, i) => {
      if (!desText.includes(line)) {
        result += `‚ö† ÂéüÁ®ø„ÅÆÊñá„Äå${line}„Äç„Åå„Éá„Ç∂„Ç§„É≥„Å´Ë¶ã„Å§„Åã„Çä„Åæ„Åõ„Çì\n`;
      }
    });
  }

  resultDiv.innerText = result || "‚úÖ ÂïèÈ°å„Å™„ÅóÔºÅ";
}

// ÂéüÁ®ø„Éï„Ç°„Ç§„É´Ë™≠„ÅøËæº„ÅøÔºàPDF„Åæ„Åü„ÅØExcelÔºâ
document.getElementById("sourceFile").addEventListener("change", async (e) => {
  const file = e.target.files[0];
  const mode = document.querySelector("input[name='sourceMode']:checked").value;
  const useOCR = document.getElementById("useOCR").checked;
  if (!file) return;

  if (mode === "excel") {
    const reader = new FileReader();
    reader.onload = function (e) {
      const data = new Uint8Array(e.target.result);
      const workbook = XLSX.read(data, { type: "array" });
      const sheetName = workbook.SheetNames[0];
      const sheet = workbook.Sheets[sheetName];
      const text = XLSX.utils.sheet_to_csv(sheet);
      document.getElementById("sourceText").value = text;
    };
    reader.readAsArrayBuffer(file);
  } else if (mode === "pdf") {
    const reader = new FileReader();
    reader.onload = async function () {
      const typedarray = new Uint8Array(this.result);
      const pdf = await pdfjsLib.getDocument({ data: typedarray }).promise;

      let fullText = "";
      for (let i = 1; i <= pdf.numPages; i++) {
        const page = await pdf.getPage(i);
        const canvas = document.getElementById("hiddenCanvas");
        const ctx = canvas.getContext("2d");
        const viewport = page.getViewport({ scale: 2 });
        canvas.width = viewport.width;
        canvas.height = viewport.height;
        await page.render({ canvasContext: ctx, viewport: viewport }).promise;

        if (useOCR) {
          const { data: { text } } = await Tesseract.recognize(canvas, 'jpn');
          fullText += text + "\n";
        } else {
          const textContent = await page.getTextContent();
          const strings = textContent.items.map((item) => item.str);
          fullText += strings.join(" ") + "\n";
        }
      }
      document.getElementById("sourceText").value = fullText;
    };
    reader.readAsArrayBuffer(file);
  }
});

// ÂÆåÊàê„Éá„Ç∂„Ç§„É≥PDFË™≠„ÅøËæº„Åø
document.getElementById("designPDF").addEventListener("change", async (e) => {
  const file = e.target.files[0];
  if (!file) return;

  const reader = new FileReader();
  reader.onload = async function () {
    const typedarray = new Uint8Array(this.result);
    const pdf = await pdfjsLib.getDocument({ data: typedarray }).promise;

    let fullText = "";
    for (let i = 1; i <= pdf.numPages; i++) {
      const page = await pdf.getPage(i);
      const textContent = await page.getTextContent();
      const strings = textContent.items.map((item) => item.str);
      fullText += strings.join(" ") + "\n";
    }
    document.getElementById("designText").value = fullText;
  };
  reader.readAsArrayBuffer(file);
});
